فصل ۱ آپدیت: معرفی کلی آپدیت دوره
275: وویس بود. نکاتی که داشت:
DRF مخفف Django Rest Framework هست.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۲ آپدیت: مقدمات
276: جنگو چیه؟ نکته خاصی نداشت.
277: نصب ادیتور و پایتون. نکته خاصی نداشت.
278: محیط مجازی پروژه. نکاتی که داشت:
تو مک برای دیدن دایرکتوری فعلی دستور pwd رو میشه نوشت تو ترمینال. تو ویندوز که cd هست.
279: ساخت اولین پروژه جنگو. نکاتی که داشت:
استفاده از pipenv برای ساخت پروژه. اول با pip install pipenv خود pipenv رو نصب میکنیم.
بعد هم با دستور pipenv install django جنگو رو اونجا نصب میکنیم که نسبت به venv کمتر دردسر داره و کمتر صفحه
شلوغ میشه. (نصبش بسته به کتابخونه و اینترنت ممکنه طول بکشه.) بعد دستور pipenv shell رو میزنیم که ازش استفاده کنیم.
asgi و wsgi برای دیپلوی کردن و مدیریت سرور هستند.
آخرای فایلش هم گفت که اگه vscode پایتون رو نشناخت، چه طوری به عنوان interpreter انتخابش کنیم که دیگه زیرشون خط نکشه.
280: مفهوم اپ ها در جنگو. نکاتی که داشت:
نکته مهم این که وقتی چندین تا اپ میسازیم، باید طوری بنویسیم که اپ ها هیچ وابستگی ای به هم نداشته باشند. اگه دارن پس
باید داخل یه اپ بنویسیمشون و نباید چند تا اپ باشن.
281: مفهوم url و view ها. نکته خاصی نداشت.
282: تمرین url ها. نکته خاصی نداشت.
283: نحوه ورودی گرفتن از url ها. نکاتی که داشت:
جنس متغیری که از طریق url به view ارسال میشه پیش فرض str هست. با <int:esmesh> میتونیم بگیم که مثلا جنسش int هست.
284: مفهوم تمپلیت و استفاده از آن. نکته خاصی نداشت.
285: استفاده از دیباگ تولبار حرفه ای جنگو. نکاتی که داشت:
جنگو دیباگ تولبار رو اضافه کرد که مرحله به مرحله از تو سایتش انجام داد. سرچ کنم django debug toolbar. همون لینک اول
سایتشون هست که مرحله به مرحله نوشته چیکار کنیم. نکته ای که داشت و گفت این بود که برای این که تو صفحه های 
جنگو بیاد، تمپلیت حتما باید داخل تگ html نوشته بشه. اگه تگ html نباشه کار نمیکنه. نکته ای که خودم به مشکل خوردم 
این بود که تو middleware باید اون خط رو به عنوان اولین عضو لیست کپی کنیم که تو سایتش هم وارنینگ نوشته بود من دقت
نکردم. البته دقیق ترش تو سایتش نوشته. نباید اول باشه. باید در جای مناسب باشه. اما این پروژه چون خالی 
بود و middleware دیگه ای نداشت اولش باید اضافه کنیم.
286: نحوه دیباگ کردن پروژه های جنگو. نکاتی که داشت:
این جدا از دیباگ تولباری هست که نصب کردیم. اگه لازم باشه که با خود پایتون خودمون دیباگ کنیم مثل کدهای قبلی، میتونیم
از این روش استفاده کنیم. احتمالا با دیباگ تولبار خیلی دیگه لازم نشه. اما نوشتم که داشته باشم. چون فیلمش قطع و 
وصل شده بود و درست چیزی نفهمیدم خودم یه کم ور رفتم با وی اس کد دیدم که این شکلیه. تو قسمت دیباگ که بریم
دکمه آبی بزرگ که نوشته run and debug فایلی که روش هستیم رو اجرا میکنه فقط و اون رو دیباگ میکنه. اما زیرش یه لینک 
آبی داره create a launch.json file که با کلیک روش میگه چه فایل جیسونی میخوای؟ برای من پایتون فایل و ماجول و جنگو و
فلسک و FastAPI و Flutter و چند تا دیگه داشت که فکر کنم بر اساس اکستنشن ها و کتابخونه هایی که نصب کنیم تغییر بکنه.
خلاصه این که جنگو رو انتخاب کردم و یه فایل به اسم launch.json درست کرد که داخل یه پوشه به اسم .vscode در کنار 
پروژه میذاره. البته هر کودوم از بقیه ها رو هم انتخاب کنیم همین کار رو انجام میده و فایل رو میسازه. بعد از اون هم
یه دکمه آبی Add Configuration... داره که بشه همزمان دیباگ حالت های مختلف رو تو فایل launch.json نوشت. خلاصه برای
جنگو تو کلید args، به عنوان مقدار یه لیست میگیره که خودش runserver رو نوشته بود. ما هم به عنوان ورودی دوم یه پورت
رو بهش میدیم که البته به صورت استرینگ باید باشه. از این به بعد تو همون منوی سمت چپ قسمت دیباگ به جای آوردن اون
دکمه آبی رنگ، یه فلش میاره و دکمه تنظیمات و چیزای دیگه. برای شروع دیباگ رو فلش کلیک می کنیم و دیباگ شروع میشه.
(یه مشکل دیگه هم که برخوردم یادم باشه این بود که دیباگ تولبار رو توی pipenv نصب کرده بودم و تو سیستم انگار که نصب
نشده بود و نمیشناختش. برای این که run بشه رو کل سیستم هم نصبش کردم.)
287: دو نکته تکمیلی. نکاتی که داشت.
با زدن ctrl+shift+p میتونیم اگه setting بنویسیم و settings(UI) رو انتخاب کنیم، میتونیم بگیم که تو قسمت اکسپلورر
سمت چپ پروژه ها چه چیزهایی رو نمایش بده یا نده. مثل همین فولدر .vscode یا .git و غیره. تو سرچش بنویسم exclude
خودش یه سری ها رو میاره. نکته ای که اینجا یاد گرفتم و مهمه مثل گیت هست اینه. .git یعنی پوشه ای که اسمش .git هست
رو نشون نده. اما اگه داخل پوشه های دیگه باشه اونا رو نشون میده. */.git یعنی این پوشه نه. هر پوشه ای از اینجا
به بعد که داخلش .git داره اونا رو نشون نده. **/.git یعنی هم خود این پوشه .git و هم پوشه های داخلی که اسمشون .git
هست رو نشون نده. توی بحث خود گیت هم احتمالا همین شکلی باشه. مثلا میخوام کل فایل های pychache رو نذاره. احتمالا باید
بنویسم **/__pycache__ که هم pycache ای که بیرون هست رو اضافه نکنه و هم داخلی ها رو. به عنوان نکته آخر یادم باشه
که / علامت فولدر هست.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۳ آپدیت: Models
288: دیتابیس چیست. نکته خاصی نداشت.
289: کلیدهای خارجی و ارتباط بین جداول. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
290: انواع دیتابیس ها و جزئیات دیتابیس رابطه ای. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
291: طراحی دیتابیس پروژه. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
292: مدل کردن داده ها در جنگو. نکته خاصی نداشت.
293: ادامه ساخت مدل محصول. نکاتی که داشت:
slugField رو گفت که برای سئو هست. تعریفش تو جنگو که نکته خاصی نداره. توضیحش این که به جای این که برای دیدن جزییات
یک چیزی ما داخل url آی دیش رو بنویسیم، از slug استفاده میکنیم که میتونیم نام محصول یا نام با چند تا ویژگی رو با
همدیگه بنویسیم که با - یا آندرلاین جدا شدن. مثلا تو یو آر ال محصولات، یه محصول خاص دیگه عدد ۱۸۳۹۲۹ نیست. به جاش
کفش-چرمی-زرشکی هست که موتورهای جست و جو به این کلمات واکنش نشون میدن. اما به اون عدد واکنشی ندارن. پس برای این که
سئو سایت خوب باشه از اسلاگ فیلد استفاده میکنیم.
294: مفاهیم null و blank. نکته خاصی نداشت.
295: اضافه کردن choices به فیلدها. نکته خاصی نداشت.
296: استفاده از کلید خارجی در مدل ها. نکته خاصی نداشت.
297: رابطه یک به یک یا One to One. نکاتی که داشت:
آدرس رو اضافه کرد و با فرض این که هر کس یک آدرس داره، یک رابطه یک به یک تشکیل داد. نکته ای که داشت این هست که
متغیر primary_key=True رو بهش داد تا دیگه برای آدرس یه primary_key جدا تعریف نکنه. چون به یه کاستومر وصل هست و
اون کاستومر خودش جدا هست و پرایمری کی داره. پس لازم نیست دیگه این هم داشته باشه. خودش گفت به خاطر اینه که اگه آدرس
رو ویرایش کردیم یه سطر جدید اضافه نکنه و به همین دلیل میذاریم که ۲ تا نشه و ارور نخوره. ولی منطقا من فکر کردم اگه
آدرس رو آپدیت کنیم سطر جدید درست نمیکنه و همون رو فقط ویرایش میکنه و مشکلی نداره. اما برای این که یه پرایمری کی
الکی دیگه داخل تیبل درست نکنه، منطقی هست که این کار رو بکنیم و primary_key=True بذاریم. خلاصه این که این فیلد رو
هم ننوشتم باز ساختم اوکی بود. اما حتما دلیلی داشته که گذاشته و بذاریم بهتره. شاید دلیلش رو اشتباه متوجه شده اما
همین دلیل که آی فیلد آی دی اضافه تو این جدول تعریف نشه برای من کافیه.
298: رابطه Many to Many. نکته خاصی نداشت.
299: مبحث بسیار مهم related name. نکته خاصی نداشت.
300: تمرین relationship ها. نکته قابل نوشتن نداشت. فیلم رو دوباره باید دید.
301: ارور مهم circular dependency و نحوه حل مشکل. نکاتی که داشت.
اگه دو تا مدل داریم که به همدیگه فارین کی میزنن، هر دو تا رو نمیشه بالای هم تعریف کرد. اونی که اول اومده و موقع
تعریف فارین کی ارور میده که کلاس دوم رو نمیشناسه، کلاس رو داخل کوتیشن میذاریم که ارور نده و در واقع بهش میگیم بعدا
اسم کلاسش رو این بذاره. اما فقط زمانی که دو تا کلاس به هم وابسته هستند این کار رو بکنیم. دور همه کوتیشن نذاریم و 
به استرینگ تبدیل نکنیم همه کلاس ها رو.
302: درک بهتر related name. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
303: نکته مهم درباره ارور query name clash. نکاتی که داشت:
اگه تو رابطه ای که نوشتیم، related_name ای که گذاشتیم (یا نذاشتیم و خود جنگو گذاشته) توی اون یکی مدل وجود داشته
باشه، بهمون ارور میده موقع runserver. یا باید اسم اون فیلد رو عوض کنیم یا اسم related_name رو. اگر احیانا لازمش
نداشتیم و نمیخواستیم از اون به این برسیم، میتونیم بنویسیم related_name='+' که یعنی به جنگو میگیم تو اصلا این
related_name رو براش تعریف نکن. من نمیخوام که از اون به این برسم.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۴ آپدیت: دیتابیس
304: دیتابیس های سازگار جنگو. نکته خاصی نداشت.
305: نحوه ساخت migration. نکته خاصی نداشت.
306: ادامه مبحث ساخت migration. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
307: مفهوم و نحوه migrate. نکاتی که داشت:
برای دیدن sqlite، اکستنشن SQLite رو نصب کنیم. (SQLiteViewer نه. با این فقط میشه دید.) بعد روی اسم دیتابیس کیلک
راست و open database رو بزنیم. تو سمت چپ و قسمت explorer پروژه یه قسمت SQLite EXPLORER اضافه میشه که از اونجا
میتونیم با دیتابیس sqlite کار کنیم.
308: کد معادل sql مایگریشن ما. نکاتی که داشت:
برای دیدن معادل SQL دستوراتی که نوشتیم، میتونیم از دستور py manage.py sqlmigrate store 0005 استفاده کنیم که کلمه
store اسم اپمون و 0005 شماره مایگریشنی بود که میخواستیم دستور معادلش رو ببینیم.
برای تغییر نام تیبلی که به صورت پیش فرض خود جنگو از رو اسم مدلی که گذاشتیم میذاره، میتونیم داخل اون کلاس یه کلاس
Meta تعریف کنیم و داخلش متغیر db_table رو با اسم دلخواهمون پر کنیم. جالب بود. اما پیشنهادش هم این بود که خودمون
تغییر ندیم.
309: نحوه بازگردانی مایگریشن ها. نکاتی که داشت.
برای مایگریت کردن تا یه جای مشخص، میتونیم اسم اپ و شماره مایگریشن رو بنویسیم. مثلا ۶ تا مایگریشن داریم. اما میخوایم
۵ رو انجام بده برای همین اپ استور. مینویسیم: py manage.py migrate store 0005.
310: دانلود و نصب mysql. نکته خاصی نداشت.
311: اتصال پروژه به mysql. نکاتی که داشت.
نکته خاصی که نداشت. فقط دقت کنم که دیتابیس رو باید بسازیم. بعد تو پایتون تو settings وصلش کنیم. و این که تمام حروف
اون متغیرها باید بزرگ باشه USER و ... pymysql هم نصب باید باشه. اخیرا mysqlclient جواب نمیده. پس pymysql رو نصب
میکنیم و تو فایل __init__ از config این رو مینویسیم.
import pymysql
pymysql.install_as_MySQLdb()
این طوری مشکل حل شد که تو فیلم نبود. خانم معتمد حل کرد. و لینک استک اورفلو رو هم ذخیره کردم تو بخش جنگو خودم.
312: منطق app ها در جنگو. نکاتی که داشت:
راجع به این گفت که اگه یه اپمون این شکلی همه کلاس ها داخلش باشه و view و اینا رو داخلش بنویسیم، قابل استفاده مجدد
هست. در حالی که اگه یه اپ cart داشته باشیم یه اپ order یه اپ customer، مجبور میشیم اینا رو به هم وصل کنیم و این
طوری نمیشه از هیچ کودوم به تنهایی استفاده کرد. البته اون مدلی هم کاربرد داره و سایت میسازن. اما برای استفاده مجدد
از یه اپ تو پروژه دیگه مون، اگر این کار رو بکنیم که یه اپ کاملا مستقل باشه، میشه ازش تو پروژه های دیگه هم استفاده
کرد.
313: استفاده از faker و factory برای تولید دیتا. نکاتی که داشت:
برای استفاده از faker، دستور pip install faker رو مینویسیم و نصبش می کنیم. برای استفاده ازش داکیومنتیشن کامل داره
تو آدرس https://faker.readthedocs.io/en/master/
factory boy برای اینه که جنگو رو به faker وصل کنیم که بیاد دیتابیس ما رو راحت تر برامون پر بکنه. آدرس کامل
داکیومنتیشنش هم https://factoryboy.readthedocs.io/en/stable/ هست. و با دستور pip install factory_boy نصب میشه.
یه فایل به اسم factories.py گذاشت که دانلودش کردم. توضیح خیلی خاصی نداشت و با نگاه کردن کدها متوجه میشم. از روی
همین نمونه میتونیم factory های دیگه هم خودمون درست کنیم. دیدن دوباره فیلم لازم نیست و همینا که نوشتم و خووندن فایل
factoryboy.py کافیه. نکته آخر این که فقط تو کلاسهای فکتوری، اونایی که فارین کی بودند یا رابطه داشتن با یه جدول دیگه
اونا رو تعیین نکرده بود.
314: اجرای faker. نکاتی که داشت:
اول میخوایم فایل factories.py رو اجرا کنیم. یاد میگیریم که چه طور دستور خودمون رو به جنگو اضافه کنیم.
داخل اپمون باید یه فولدر بسازیم به اسم management. داخل اون یه فولدر دیگه بسازیم به اسم commands. داخل اون یک فایل
پایتون میسازیم. مثلا setup_fake_data.py. اینجا یه کلاس مینویسیم که حتما باید اسمش Command باشه (C بزرگ هست.) و از
BaseCommand ارث بری میکنه که داخل django.core.management.base هست. داخلش یه تابع به اسم handle بنویسیم که ورودی های
args و kwargs هم یادمون نره. داخل اون میتونیم بنویسیم که چیکار کنه. بعد از این کارها میتونیم بنویسیم
python manage.py py که حالا هر اسمی برای اون میتونیم بنویسیم. یا اگه بنویسیم py manage.py خودش میگه که با چه
ورودی ای و فایلی که خودمون درست کردیم رو هم به ما نشون میده. توضیحاتی که داد خیلی مهم نیست و فیلم رو لازم نیست
دوباره ببینم. اما فایل رو بررسی کنم که نحوه نوشتن کدهای faker رو یاد بگیرم. بعد از این که فایل خودش رو به پروژه
اضافه کردیم، با دستور py manage.py setup_fake_data میتونیم دیتابیسمون رو با اطلاعات پر کنیم.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۵ آپدیت: ORM & queries
315: مفهوم ORM و query ها. نکته خاصی نداشت.
316: دانلود فایل پروژه. دانلود کردم و رو درایو گذاشتم.
317: مفهوم querysets ها و lazyness بودن. نکاتی که داشت:
تا وسط هاش نکته خاصی نداشت. از وسطش راجع به lazy بودن کوئری هایی که میزنیم توضیح داد که خیلی جالب بود. وقتی دستور
all یا filter یا بقیه رو با manager اون کلاس مینویسیم، کوئری رو اجرا نمیکنه. و lazy هست. در واقع توی کد صبر میکنه تا
به جایی برسه که ما ازش استفاده کردیم و اونجا هست که به دیتابیس کوئری رو میزنه که الکی وقت دیتابیس رو با کوئری های
زیاد نگیره. این میشه مفهوم lazy بودن که باعث سریعتر شدن سایتمون میشه. تو سه حالت که میبینه ما واقعا به اطلاعات نیاز
داریم کوئری رو به دیتابیس میفرسته. ۱- iterate بکنیم رو جواب. مثلا for بنویسیم. ۲- تبدیلش بکنیم به لیست یا چیزی که
متوجه بشه میخوایم تو برنامه ازش استفاده بکنیم. ۳- اسلایسش کنیم مثلا اندیس ۳ تا ۱۰ رو از توش در بیاریم که باز هم متوجه
میشه که ما منتظر دیتابیس هستیم و لازمش داریم. اینجا هست که دستور رو انجام میده. اینا رو تو دیباگ تولبار هم نشون داد.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۶ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۷ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۸ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۹ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۰ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۱ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۲ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
