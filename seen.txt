فصل ۱ آپدیت: معرفی کلی آپدیت دوره
280: وویس بود. نکاتی که داشت:
DRF مخفف Django Rest Framework هست.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۲ آپدیت: مقدمات
281: جنگو چیه؟ نکته خاصی نداشت.
282: نصب ادیتور و پایتون. نکته خاصی نداشت.
283: محیط مجازی پروژه. نکاتی که داشت:
تو مک برای دیدن دایرکتوری فعلی دستور pwd رو میشه نوشت تو ترمینال. تو ویندوز که cd هست.
284: ساخت اولین پروژه جنگو. نکاتی که داشت:
استفاده از pipenv برای ساخت پروژه. اول با pip install pipenv خود pipenv رو نصب میکنیم.
بعد هم با دستور pipenv install django جنگو رو اونجا نصب میکنیم که نسبت به venv کمتر دردسر داره و کمتر صفحه
شلوغ میشه. (نصبش بسته به کتابخونه و اینترنت ممکنه طول بکشه.) بعد دستور pipenv shell رو میزنیم که ازش استفاده کنیم.
asgi و wsgi برای دیپلوی کردن و مدیریت سرور هستند.
آخرای فایلش هم گفت که اگه vscode پایتون رو نشناخت، چه طوری به عنوان interpreter انتخابش کنیم که دیگه زیرشون خط نکشه.
285: مفهوم اپ ها در جنگو. نکاتی که داشت:
نکته مهم این که وقتی چندین تا اپ میسازیم، باید طوری بنویسیم که اپ ها هیچ وابستگی ای به هم نداشته باشند. اگه دارن پس
باید داخل یه اپ بنویسیمشون و نباید چند تا اپ باشن.
286: مفهوم url و view ها. نکته خاصی نداشت.
287: تمرین url ها. نکته خاصی نداشت.
288: نحوه ورودی گرفتن از url ها. نکاتی که داشت:
جنس متغیری که از طریق url به view ارسال میشه پیش فرض str هست. با <int:esmesh> میتونیم بگیم که مثلا جنسش int هست.
289: مفهوم تمپلیت و استفاده از آن. نکته خاصی نداشت.
290: استفاده از دیباگ تولبار حرفه ای جنگو. نکاتی که داشت:
جنگو دیباگ تولبار رو اضافه کرد که مرحله به مرحله از تو سایتش انجام داد. سرچ کنم django debug toolbar. همون لینک اول
سایتشون هست که مرحله به مرحله نوشته چیکار کنیم. نکته ای که داشت و گفت این بود که برای این که تو صفحه های
جنگو بیاد، تمپلیت حتما باید داخل تگ html نوشته بشه. اگه تگ html نباشه کار نمیکنه. نکته ای که خودم به مشکل خوردم
این بود که تو middleware باید اون خط رو به عنوان اولین عضو لیست کپی کنیم که تو سایتش هم وارنینگ نوشته بود من دقت
نکردم. البته دقیق ترش تو سایتش نوشته. نباید اول باشه. باید در جای مناسب باشه. اما این پروژه چون خالی
بود و middleware دیگه ای نداشت اولش باید اضافه کنیم.
291: نحوه دیباگ کردن پروژه های جنگو. نکاتی که داشت:
این جدا از دیباگ تولباری هست که نصب کردیم. اگه لازم باشه که با خود پایتون خودمون دیباگ کنیم مثل کدهای قبلی، میتونیم
از این روش استفاده کنیم. احتمالا با دیباگ تولبار خیلی دیگه لازم نشه. اما نوشتم که داشته باشم. چون فیلمش قطع و
وصل شده بود و درست چیزی نفهمیدم خودم یه کم ور رفتم با وی اس کد دیدم که این شکلیه. تو قسمت دیباگ که بریم
دکمه آبی بزرگ که نوشته run and debug فایلی که روش هستیم رو اجرا میکنه فقط و اون رو دیباگ میکنه. اما زیرش یه لینک
آبی داره create a launch.json file که با کلیک روش میگه چه فایل جیسونی میخوای؟ برای من پایتون فایل و ماجول و جنگو و
فلسک و FastAPI و Flutter و چند تا دیگه داشت که فکر کنم بر اساس اکستنشن ها و کتابخونه هایی که نصب کنیم تغییر بکنه.
خلاصه این که جنگو رو انتخاب کردم و یه فایل به اسم launch.json درست کرد که داخل یه پوشه به اسم .vscode در کنار
پروژه میذاره. البته هر کودوم از بقیه ها رو هم انتخاب کنیم همین کار رو انجام میده و فایل رو میسازه. بعد از اون هم
یه دکمه آبی Add Configuration... داره که بشه همزمان دیباگ حالت های مختلف رو تو فایل launch.json نوشت. خلاصه برای
جنگو تو کلید args، به عنوان مقدار یه لیست میگیره که خودش runserver رو نوشته بود. ما هم به عنوان ورودی دوم یه پورت
رو بهش میدیم که البته به صورت استرینگ باید باشه. از این به بعد تو همون منوی سمت چپ قسمت دیباگ به جای آوردن اون
دکمه آبی رنگ، یه فلش میاره و دکمه تنظیمات و چیزای دیگه. برای شروع دیباگ رو فلش کلیک می کنیم و دیباگ شروع میشه.
(یه مشکل دیگه هم که برخوردم یادم باشه این بود که دیباگ تولبار رو توی pipenv نصب کرده بودم و تو سیستم انگار که نصب
نشده بود و نمیشناختش. برای این که run بشه رو کل سیستم هم نصبش کردم.)
292: دو نکته تکمیلی. نکاتی که داشت.
با زدن ctrl+shift+p میتونیم اگه setting بنویسیم و settings(UI) رو انتخاب کنیم، میتونیم بگیم که تو قسمت اکسپلورر
سمت چپ پروژه ها چه چیزهایی رو نمایش بده یا نده. مثل همین فولدر .vscode یا .git و غیره. تو سرچش بنویسم exclude
خودش یه سری ها رو میاره. نکته ای که اینجا یاد گرفتم و مهمه مثل گیت هست اینه. .git یعنی پوشه ای که اسمش .git هست
رو نشون نده. اما اگه داخل پوشه های دیگه باشه اونا رو نشون میده. */.git یعنی این پوشه نه. هر پوشه ای از اینجا
به بعد که داخلش .git داره اونا رو نشون نده. **/.git یعنی هم خود این پوشه .git و هم پوشه های داخلی که اسمشون .git
هست رو نشون نده. توی بحث خود گیت هم احتمالا همین شکلی باشه. مثلا میخوام کل فایل های pychache رو نذاره. احتمالا باید
بنویسم **/__pycache__ که هم pycache ای که بیرون هست رو اضافه نکنه و هم داخلی ها رو. به عنوان نکته آخر یادم باشه
که / علامت فولدر هست.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۳ آپدیت: Models
293: دیتابیس چیست. نکته خاصی نداشت.
294: کلیدهای خارجی و ارتباط بین جداول. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
295: انواع دیتابیس ها و جزئیات دیتابیس رابطه ای. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
296: طراحی دیتابیس پروژه. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
297: مدل کردن داده ها در جنگو. نکته خاصی نداشت.
298: ادامه ساخت مدل محصول. نکاتی که داشت:
slugField رو گفت که برای سئو هست. تعریفش تو جنگو که نکته خاصی نداره. توضیحش این که به جای این که برای دیدن جزییات
یک چیزی ما داخل url آی دیش رو بنویسیم، از slug استفاده میکنیم که میتونیم نام محصول یا نام با چند تا ویژگی رو با
همدیگه بنویسیم که با - یا آندرلاین جدا شدن. مثلا تو یو آر ال محصولات، یه محصول خاص دیگه عدد ۱۸۳۹۲۹ نیست. به جاش
کفش-چرمی-زرشکی هست که موتورهای جست و جو به این کلمات واکنش نشون میدن. اما به اون عدد واکنشی ندارن. پس برای این که
سئو سایت خوب باشه از اسلاگ فیلد استفاده میکنیم.
299: مفاهیم null و blank. نکته خاصی نداشت.
300: اضافه کردن choices به فیلدها. نکته خاصی نداشت.
301: استفاده از کلید خارجی در مدل ها. نکته خاصی نداشت.
302: رابطه یک به یک یا One to One. نکاتی که داشت:
آدرس رو اضافه کرد و با فرض این که هر کس یک آدرس داره، یک رابطه یک به یک تشکیل داد. نکته ای که داشت این هست که
متغیر primary_key=True رو بهش داد تا دیگه برای آدرس یه primary_key جدا تعریف نکنه. چون به یه کاستومر وصل هست و
اون کاستومر خودش جدا هست و پرایمری کی داره. پس لازم نیست دیگه این هم داشته باشه. خودش گفت به خاطر اینه که اگه آدرس
رو ویرایش کردیم یه سطر جدید اضافه نکنه و به همین دلیل میذاریم که ۲ تا نشه و ارور نخوره. ولی منطقا من فکر کردم اگه
آدرس رو آپدیت کنیم سطر جدید درست نمیکنه و همون رو فقط ویرایش میکنه و مشکلی نداره. اما برای این که یه پرایمری کی
الکی دیگه داخل تیبل درست نکنه، منطقی هست که این کار رو بکنیم و primary_key=True بذاریم. خلاصه این که این فیلد رو
هم ننوشتم باز ساختم اوکی بود. اما حتما دلیلی داشته که گذاشته و بذاریم بهتره. شاید دلیلش رو اشتباه متوجه شده اما
همین دلیل که آی فیلد آی دی اضافه تو این جدول تعریف نشه برای من کافیه.
303: رابطه Many to Many. نکته خاصی نداشت.
304: مبحث بسیار مهم related name. نکته خاصی نداشت.
305: تمرین relationship ها. نکته قابل نوشتن نداشت. فیلم رو دوباره باید دید.
306: ارور مهم circular dependency و نحوه حل مشکل. نکاتی که داشت.
اگه دو تا مدل داریم که به همدیگه فارین کی میزنن، هر دو تا رو نمیشه بالای هم تعریف کرد. اونی که اول اومده و موقع
تعریف فارین کی ارور میده که کلاس دوم رو نمیشناسه، کلاس رو داخل کوتیشن میذاریم که ارور نده و در واقع بهش میگیم بعدا
اسم کلاسش رو این بذاره. اما فقط زمانی که دو تا کلاس به هم وابسته هستند این کار رو بکنیم. دور همه کوتیشن نذاریم و
به استرینگ تبدیل نکنیم همه کلاس ها رو.
307: درک بهتر related name. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
308: نکته مهم درباره ارور query name clash. نکاتی که داشت:
اگه تو رابطه ای که نوشتیم، related_name ای که گذاشتیم (یا نذاشتیم و خود جنگو گذاشته) توی اون یکی مدل وجود داشته
باشه، بهمون ارور میده موقع runserver. یا باید اسم اون فیلد رو عوض کنیم یا اسم related_name رو. اگر احیانا لازمش
نداشتیم و نمیخواستیم از اون به این برسیم، میتونیم بنویسیم related_name='+' که یعنی به جنگو میگیم تو اصلا این
related_name رو براش تعریف نکن. من نمیخوام که از اون به این برسم.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۴ آپدیت: دیتابیس
309: دیتابیس های سازگار جنگو. نکته خاصی نداشت.
310: نحوه ساخت migration. نکته خاصی نداشت.
311: ادامه مبحث ساخت migration. کلی نکته داشت. اما نمیشه نوشت. فیلم رو باید دوباره دید.
312: مفهوم و نحوه migrate. نکاتی که داشت:
برای دیدن sqlite، اکستنشن SQLite رو نصب کنیم. (SQLiteViewer نه. با این فقط میشه دید.) بعد روی اسم دیتابیس کیلک
راست و open database رو بزنیم. تو سمت چپ و قسمت explorer پروژه یه قسمت SQLite EXPLORER اضافه میشه که از اونجا
میتونیم با دیتابیس sqlite کار کنیم.
313: کد معادل sql مایگریشن ما. نکاتی که داشت:
برای دیدن معادل SQL دستوراتی که نوشتیم، میتونیم از دستور py manage.py sqlmigrate store 0005 استفاده کنیم که کلمه
store اسم اپمون و 0005 شماره مایگریشنی بود که میخواستیم دستور معادلش رو ببینیم.
برای تغییر نام تیبلی که به صورت پیش فرض خود جنگو از رو اسم مدلی که گذاشتیم میذاره، میتونیم داخل اون کلاس یه کلاس
Meta تعریف کنیم و داخلش متغیر db_table رو با اسم دلخواهمون پر کنیم. جالب بود. اما پیشنهادش هم این بود که خودمون
تغییر ندیم.
314: نحوه بازگردانی مایگریشن ها. نکاتی که داشت.
برای مایگریت کردن تا یه جای مشخص، میتونیم اسم اپ و شماره مایگریشن رو بنویسیم. مثلا ۶ تا مایگریشن داریم. اما میخوایم
۵ رو انجام بده برای همین اپ استور. مینویسیم: py manage.py migrate store 0005.
315: دانلود و نصب mysql. نکته خاصی نداشت.
316: اتصال پروژه به mysql. نکاتی که داشت.
نکته خاصی که نداشت. فقط دقت کنم که دیتابیس رو باید بسازیم. بعد تو پایتون تو settings وصلش کنیم. و این که تمام حروف
اون متغیرها باید بزرگ باشه USER و ... pymysql هم نصب باید باشه. اخیرا mysqlclient جواب نمیده. پس pymysql رو نصب
میکنیم و تو فایل __init__ از config این رو مینویسیم.
import pymysql
pymysql.install_as_MySQLdb()
این طوری مشکل حل شد که تو فیلم نبود. خانم معتمد حل کرد. و لینک استک اورفلو رو هم ذخیره کردم تو بخش جنگو خودم.
317: منطق app ها در جنگو. نکاتی که داشت:
راجع به این گفت که اگه یه اپمون این شکلی همه کلاس ها داخلش باشه و view و اینا رو داخلش بنویسیم، قابل استفاده مجدد
هست. در حالی که اگه یه اپ cart داشته باشیم یه اپ order یه اپ customer، مجبور میشیم اینا رو به هم وصل کنیم و این
طوری نمیشه از هیچ کودوم به تنهایی استفاده کرد. البته اون مدلی هم کاربرد داره و سایت میسازن. اما برای استفاده مجدد
از یه اپ تو پروژه دیگه مون، اگر این کار رو بکنیم که یه اپ کاملا مستقل باشه، میشه ازش تو پروژه های دیگه هم استفاده
کرد.
318: استفاده از faker و factory برای تولید دیتا. نکاتی که داشت:
برای استفاده از faker، دستور pip install faker رو مینویسیم و نصبش می کنیم. برای استفاده ازش داکیومنتیشن کامل داره
تو آدرس https://faker.readthedocs.io/en/master/
factory boy برای اینه که جنگو رو به faker وصل کنیم که بیاد دیتابیس ما رو راحت تر برامون پر بکنه. آدرس کامل
داکیومنتیشنش هم https://factoryboy.readthedocs.io/en/stable/ هست. و با دستور pip install factory_boy نصب میشه.
یه فایل به اسم factories.py گذاشت که دانلودش کردم. توضیح خیلی خاصی نداشت و با نگاه کردن کدها متوجه میشم. از روی
همین نمونه میتونیم factory های دیگه هم خودمون درست کنیم. دیدن دوباره فیلم لازم نیست و همینا که نوشتم و خووندن فایل
factoryboy.py کافیه. نکته آخر این که فقط تو کلاسهای فکتوری، اونایی که فارین کی بودند یا رابطه داشتن با یه جدول دیگه
اونا رو تعیین نکرده بود.
319: اجرای faker. نکاتی که داشت:
اول میخوایم فایل factories.py رو اجرا کنیم. یاد میگیریم که چه طور دستور خودمون رو به جنگو اضافه کنیم.
داخل اپمون باید یه فولدر بسازیم به اسم management. داخل اون یه فولدر دیگه بسازیم به اسم commands. داخل اون یک فایل
پایتون میسازیم. مثلا setup_fake_data.py. اینجا یه کلاس مینویسیم که حتما باید اسمش Command باشه (C بزرگ هست.) و از
BaseCommand ارث بری میکنه که داخل django.core.management.base هست. داخلش یه تابع به اسم handle بنویسیم که ورودی های
args و kwargs هم یادمون نره. داخل اون میتونیم بنویسیم که چیکار کنه. بعد از این کارها میتونیم بنویسیم
python manage.py py که حالا هر اسمی برای اون میتونیم بنویسیم. یا اگه بنویسیم py manage.py خودش میگه که با چه
ورودی ای و فایلی که خودمون درست کردیم رو هم به ما نشون میده. توضیحاتی که داد خیلی مهم نیست و فیلم رو لازم نیست
دوباره ببینم. اما فایل رو بررسی کنم که نحوه نوشتن کدهای faker رو یاد بگیرم. بعد از این که فایل خودش رو به پروژه
اضافه کردیم، با دستور py manage.py setup_fake_data میتونیم دیتابیسمون رو با اطلاعات پر کنیم.
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۵ آپدیت: ORM & queries
320: مفهوم ORM و query ها. نکته خاصی نداشت.
321: دانلود فایل پروژه. دانلود کردم و رو درایو گذاشتم.
322: مفهوم querysets ها و lazyness بودن. نکاتی که داشت:
تا وسط هاش نکته خاصی نداشت. از وسطش راجع به lazy بودن کوئری هایی که میزنیم توضیح داد که خیلی جالب بود. وقتی دستور
all یا filter یا بقیه رو با manager اون کلاس مینویسیم، کوئری رو اجرا نمیکنه. و lazy هست. در واقع توی کد صبر میکنه تا
به جایی برسه که ما ازش استفاده کردیم و اونجا هست که به دیتابیس کوئری رو میزنه که الکی وقت دیتابیس رو با کوئری های
زیاد نگیره. این میشه مفهوم lazy بودن که باعث سریعتر شدن سایتمون میشه. تو سه حالت که میبینه ما واقعا به اطلاعات نیاز
داریم کوئری رو به دیتابیس میفرسته. ۱- iterate بکنیم رو جواب. مثلا for بنویسیم. ۲- تبدیلش بکنیم به لیست یا چیزی که
متوجه بشه میخوایم تو برنامه ازش استفاده بکنیم. ۳- اسلایسش کنیم مثلا اندیس ۳ تا ۱۰ رو از توش در بیاریم که باز هم متوجه
میشه که ما منتظر دیتابیس هستیم و لازمش داریم. اینجا هست که دستور رو انجام میده. اینا رو تو دیباگ تولبار هم نشون داد.
323: نمایش نتیجه کوئری در سایت. نکاتی که داشت:
دستور all از منیجر objects، یه کوئری ست هست. به خاطر همین lazy هست. اما دستوری مثل get که منیجر objects داره، دیگه
کوئری ست نیست و یه محصول رو بهم میده و چون سریع دیتابیس میتونه یه آیتم رو با یه ویژگی پیدا کنه، این رو انجام میده.
تابع filter هم کوئری ست هست. یه نکته که وقتی فیتلر میزنیم و بعد بهش میگیم مثلا اندیس ۰ رو بده قشنگ نیست. خودش یه
تابع برای ما به اسم first درست میکنه و میشه از اون استفاده کرد. last و latest و غیره هم داره. یه تابع هم دارن به
اسم exists که به ما میگه کوئری ای که زدیم جوابش اصلا مقدار داره یا نه. مثلا دانش آموزایی که نمره شون بیشتر از ۲۰
شده جوابی نداره و به عنوان جواب یه کوئری ست خالی به ما میده. میتونیم با تابع exists بفهمیم که خالی هست یا نه. یه
بولین به ما میده.
324: استفاده از lookup ها. نکاتی که داشت:
دو تا آندرلاین لوکاپ هست که میتونیم آخرِ اسم متغیری که میخوایم بدیم، دو تا آندرلاین رو بذاریم و بعدش مثلا از lt یا gt
استفاده کنیم. معنی lookup هم میشه سرچ کردن دیگه. دیگه توضیح نمیدم. چون از اسمشون مشخصه. lookup هایی که گفت اینا
هستند:
__lt
__lte
__gt
__gte
__contains (همه جاهایی که شامل اون عبارت هست.) (حساس به بزرگ و کوچک بودن حروف)
__icontains (همه جاهایی که شامل اون عبارت هست. insensitive یعنی حساس نیست به بزرگ و کوچیک بودن حروف.)
__in که وقتی این رو مینویسیم به عنوان ورودی یه تاپل یا لیست بهش میدیم.
__startswith
__endswith
__isnull که مقدار True یا False باید بهش بدیم.
و چیز جالب اینه که میتونیم فارین کی ها رو هم وصل کنیم. مثلا برای Product که فارین کی زده به Category بنویسیم.
Product.objects.filter(category__id=5)
یعنی اونایی که کتگوری شون ۵ هست رو بده که مال یه تیبل دیگه هست. حالا همینو میشه ادامه هم داد. مثلا بنویسیم
Product.objects.filter(category__id__gt=5) یعنی اونایی که کتگوری آی دی شون بزرگتر از ۵ هست. یا حتی:
Product.objects.filter(category__title__icontains='test') یعنی اون محصولاتی که کتگوریشون داخل تایتلشون کلمه
test به کار رفته. چه حروف بزرگ و چه کوچیک.
325: استفاده از lookup های مختلف. نکاتی که داشت:
Product.objects.filter(datetime_created__year=2021) برای گرفتن سال از تو فیلد تاریخ
بعدش chaining رو گفت که میشه رو فیلتر دوباره فیلتر زد. چند بار. اما میشه با ویرگول هم جداشون کرد. اما به هر حال
میشه به هم وصلشون کرد و چندین تا رو پشت هم فیلتر کرد که تو ادامه به کارمون میاد. دیگه بقیه لوکاپ ها رو میشه بر
اساس نیاز پیدا کرد. تو سایت خود جنگو هم که کاملش تو بخش django queryset lookups سرچ کنیم پیدا میشه لیست کاملشون.
326: تمرین درک بهتر کوئری ست ها. نکاتی که داشت:
تمرین های خیلی جالبی بود. حتما خودم هم انجام بدم دفعه بعد. دفعه اول که خیلی حال داد و واقعا جالب بود.
سرچ هم کردم و برای بیشتر از ۳ و کمتر از ۱۰ between هم پیدا کردم که از lookup رنج یعنی __range استفاده میشه
که به عنوان ورودی یه تاپل دو تایی میگیره که محدوده ای که میخوایم هست. یه نکته ای که داشت این بود که برای فیلد
فارین کی، خود جنگو با یه آندرلاین رو درست میکنه. یعنی من اولی رو نوشته بودم
OrderItem.objects.filter(product__id=1) اما برای فیلد فارین کی که اسمش id هست خود جنگو
OrderItem.objects.filter(product_id=1) رو قبول میکنه و وقتی حتی من ۲ تا آندرلاین هم گذاشته بودم تو دیباگ تولبار
یه دونه ایش رو میارود. نکته مهم دوم اینه که اگه بخوایم یه چیزی رو not کنیم، به جای تابع filter از تابع exclude
استفاده می کنیم که اون هم یه کوئری ست هست و میشه چند تا رو پشت هم نوشت یا exclude رو با filter ترکیب کرد.
327: ادامه تمرین کوئری ست ها. نکاتی که داشت:
کوئری ست آخر جالب بود که خودم اول چند تا رو زنجیر وار نوشتم. تو توضیحات گفت که میتونیم برای درک بهتر جدا بنویسیم
و خود جنگو دوباره درستش میکنه. نکته خاص دیگه ای نداشت.
328: مفهوم و استفاده از Q object. نکاتی که داشت:
تو فیلتر یا exclude، اگه ویرگول بذاریم and میکنه و چیزی برای or نداریم. مثلا میخوایم اونایی که اسمشون محمد هست رو
بگیریم یا اونایی که تو فامیلیشون کلمه محمد به کار رفته. اگه | بذاریم کار نمیکنه. چون تو پایتون به صورت معمولی
به عنوان ورودی تابع نمیتونیم اون رو بدیم. اما جنگو یه چیزی به اسم Q object درست کرده که import ش میکنیم.
از django.db.models. اسم کلاسش هم Q خالی هست D:. نحوه استفاده اش تو کد مشخصه.
به جای | میشه از & هم استفاده کرد برای and کردن. ولی خب چه کاریه :))))))))) اون رو خود تابع ها پشتیبانی میکنن.
برای نقیض کردن هم میشه از ~ پشت یه Q آبجکت استفاده کرد.
329: مفهوم و استفاده از F object. نکاتی که داشت:
اگه لازم باشه که ما دو تا فیلد از یه جدول رو با همدیگه مقایسه کنیم، میتونیم از همون django.db.models، اف رو هم
ایمپورت کنیم. نحوه استفاده ازش تو کد معلومه. برای اینه که مثلا فیلتر کنیم پست هایی که تاریخ ایجاد با تاریخ ویرایششون
یکی هست. یا مثلا افرادی که اسمشون با فامیلشون یکی هست. یا مثلا قیمت محصولاتی که تعداد محصول با قیمت برابره یا
همچین چیزهایی رو میشه با F object سرچ کرد.
330: استفاده از indexing در کوئری ها. نکاتی که داشت:
برای گرفتن محدوده مشخص، تو کوئری ست میتونیم بنویسیم:
products = Product.objects.all()[:40]
products = Product.objects.all()[20:50]
که این شکلی از دستور limit توی sql استفاده میکنه.
products = Product.objects.all()[20:80:10]
این هم نوشتم و کار هم کرد. اما کوئری ایندکسینگ کامل نیست. چون تو دستورش از همون قبلی استفاده میکرد. حالا خود
پایتون ۱۰ تا در میون اونا رو بهمون تحویل میده. در واقع وقتی نوشتم
products = Product.objects.all()[::100]
همه ۱۰۰۰ تا رو بهم تحویل داد دیتابیس و تو دیباگ تولبار هم دستورش لیمیت نداشت. اما با پایتون ما ۱۰ تاشو از تو این
۱۰۰۰ تا در آوردیم و این دیگه کوئری ایندکسینگ نیست. اما قبلی ها بود و تو دستور خود sql از دستور limit استفاده می کرد.
331: استفاده از order_by و reverse: نکاتی که داشت:
order_by که نکته خاصی نداشت. فقط میشه پشت اون فیلد منها گذاشت که نزولی مرتب کنه. متد reverse هم براشون تعریف کردن تو
جنگو. یعنی به جای اون منفی میتونیم بعد از order_by برعکسش هم بکنیم و دیگه منفی نذاریم. البته وقتی اصلا مرتب نکردم
و فقط از reverse استفاده کردم تغییری تو خروجی نداد و حتما باید از order_by استفاده می کردم. یه جورایی انگار که وقتی
متد reverse رو صدا میکنیم کلمه ASC رو به DESC تغییر میده. وقتی هم که مرتب نشه، ASC وجود نداره که بخواد عوض بشه!!!
332: دریافت اولین و آخرین مقدار. نکاتی که داشت:
چون ما با دیتابیس کار داریم، انجام کارهای پایتونی بعضی هاش جواب نمیده. مثلا میخوایم قیمت گرونترین محصول رو بگیریم.
میتونیم از متد latest استفاده کنیم که آخرین داده در دیتابیس رو بعد از مرتب کردن بهمون میده. اگه داخل فیلدش منها
بذاریم هم اولین رو میده. حالا متد earliest هم داره که بعد از مرتب کردن اولین رو به ما میده و میتونیم منها بذاریم که
آخری رو به ما بده. به عنوان ورودی ستونی که میخوایم مرتب کنیم رو میگیرن. دو تایی هم دادم کار کرد. و توی دستور sql
هم نگاه کردم اعمال شده بود. خلاصه این که از دستورات sql با استفاده از ORM استفاده کنیم بهتره. نه این که خودمون
همه رو بگیریم بعد بگیم اندیس صفرم یا -1 رو بده. چون هم کند تره و هم مثلا اندیس -1 برای همین مثال ارور میداد.
333: مقایسه values و values_list. نکاتی که داشت:
برای این که SELECT * نزنه و همه اطلاعات رو به ما نده، میتونیم از متد values استفاده کنیم و داخلش فیلدهایی که میخوایم
بهمون بده رو بنویسیم. مثلا میتونیم بنویسیم:
products = Product.objects.values('slug', 'description', 'unit_price')
که این دیگه Object رو کامل بهمون نمیده. یه کوئری ست از دیکشنری هایی میده که توشون اسلاگ و دیسکریپشن و یونیت پرایس رو
میده. در آبجکت Product به ما نمیده. یه دیکشنری میده که بعضی از مقادیری که ما تعیین کردیم توشون هستند.
اگه بخوایم یه حلقه روشون بنویسیم، هر بار دیکشنری رو مینویسه. یعنی مثلا مینویسه name: felan, price: felan و مرتب این رو
تکرار میکنه. خب ساختار تیبل مشخص هست و همه ۱۰۰ تا آیتیمی که به ما داده همین دیکشنری رو با همین کلید ها دارن. ما میتونیم
از تابع values_list استفاده کنیم که یه لیست از تاپل هایی بهمون میده که هر تاپل، اون مقادیر رو به ترتیب ذخیره کرده.
در واقع دقیقا مثل تابع fetchall عمل میکنه. نکته آخر این که متد distinct باعث میشه که تکراری ها حذف بشن. از تو نتیجه.
334: مفهوم only و defer. نکاتی که داشت:
با only، میتونیم مثل all، همه داده های مدل رو بگیریم منتهی فیلدهای خاصی رو. در واقع به جای SELECT * میتونیم بگیم مثلا
only('id', 'name') که آی دی و اسم همه رو بگیره. اما یه نکته خیلی مهم داره. اگه تو html ازشون استفاده نشه، اوکی هست. اما
اگه تو html مثلا ما از datetime_created یا description استفاده کنیم، به ازای هر داده ای که پیدا نمیکنه، دوباره میاد یه
کوئری به دیتابیس میزنه که وحشتناک کند میشه. مثلا برای خودش ۱۰۰۰ تا شد. چون برای هیچ کودوم اون آیتم رو نداشت. برای من که
داغان بود. چون از فارین کی ها هم استفاده کرده بودم و بیشتر از ۴۰۰۰ تا کوئری زده بود. اصن یه وضعی بود. خلاصه موقع استفاده
از only خیلی باید دقت کرد. اگه دقیقا میدونیم از چیا میخوایم استفاده کنیم و همونا رو استفاده کنیم اوکی هست. اما اگه تو
html بخواد از یه فیلد جدیدی از اون آیتم استفاده بشه، درخواست های زیادی به دیتابیس میفرسته و خیلی کند میشه.
فرقش با values چیه که استفاده میکردیم، values از فیلدهایی که گرفته یه دیکشنری درست میکنه و مقادیری رو که نداریم تولید
نمیکنه و تو html اگه بهش بگیم بخشی رو نشون بده که وجود نداره، خالی میذاره. اما only، آبجکت کامل رو برمیگردونه و فقط
فیلدهایی که تعیین کردیم رو میگیره. حالا اگه برای html نفرستاده باشیم، چون آبجکت رو داره دوباره درخواست میزنه میگه فلان
اطلاعات از این آبجکت رو بده که باعث تعداد کوئری های زیاد میشه. کلا استفاده از values کمتر باعث کندی میشه. اما اگه خیلی تسلط
داریم روی اطلاعات و دقیقا میدونیم که چیو میخوایم و تو html از چیا استفاده نمیشه، only رو میشه نوشت که به خود آبجکت هم
دسترسی داشته باشیم.
متد بعدی، defer هست که برعکس only هست. اگه بخوایم فیلد های خاصی رو نگیره میتونیم استفاده کنیم. اما این هم آبجکت بر میگردونه
و اگه از چیزی که گفتیم نمیخوایم تو html استفاده کنیم، باز هم درخواست میزنه به دیتابیس و کند میشه. خودش گفت از only و defer
خیلی کم استفاده میکنه. آخرین نکته خودم هم این که id رو نمیشه کاری کرد که نگیره. در هر صورت تو دیباگ تولبار id رو میگرفت.
335: استفاده از select_related. نکاتی که داشت:
نکته خیلی مهم: اگه ما از یه تیبل داریم اطلاعاتی رو میگیریم که یکی (یا چندتاشون) فارین کی هستند به یه تیبل دیگه و بعد میخوایم
که اطلاعات جزیی رو از اون تیبل دوم بگیریم، تو این حالت هم اگه بنویسیم از تو اون پروداکت مثلا برو تو کتگوری و بعد مثلا برو توی
دیسکریپشن کتگوری رو در بیار، اگه ۱۰۰۰ تا باشه ۱۰۰۰ بار درخواست میزنه به دیتابیس به دلیل مشابهی که برای only و defer بود. چون
فارین کی به آی دی تیبل دیگه وصله. برای این که INNER JOIN استفاده کنه و از اول همه اطلاعات اون رو بگیره میتونیم از متد
select_related استفاده کنیم. یعنی مثلا این طوری بنویسیم.
products = Product.objects.all().select_related('category')
یا مثلا خودم اینجا دقت کرده بودم که مشکلی با html نداشته باشه و این دستور رو هم فرستادم مشکلی نداشت.
products = Product.objects.only('id', 'name', 'description', 'unit_price', 'category').select_related('category')
این طوری به جای ۱۰۰۵ تا کوئری به دیتابیس، فقط ۵ تا زده بود و خیلی خیلی سریعتر بود. در ضمن ترتیب صدا کردن کوئری ست ها رو
هم تست کردم جابه جا کنیم مشکلی نداره. تو خود دستور SQL خودش به همون صورت مینویسه. تمرینش رو هم انجام دادم. کلا چیز سختی
نبود ولی خیلی خیلی مهمه.
نکته آخر خودم.
products = Product.objects.select_related('category').only('id', 'name', 'description', 'unit_price', 'category', 'category__title', 'category__description')
این دستور رو نوشتم که از تیبل دوم، فقط تایتل و دیسکریپشن رو بگیرم. چون ما داریم رو کلاس Product منیجر objects رو صدا میکنیم،
پس جدول اصلی ای که باهاش کار داریم اون هست. بنابراین اگر فیلد های خاصی رو از تیبل دوم میخوایم، باید نحوه تعیینش رو داخل
filter یا only که نوشتم یا بقیه متدها با استفاده از __ تعیین کنیم. اگه تعیین نکنیم، خودش از جدول دوم همه رو میده. خواستم برای
مرتب تر شدن، ۲ تا only بنویسم و جدا کنم که فیلدهای تیبل اصلی جدا باشن و فیلدهای تیبل category هم جدا. اما دو بار که only رو
نوشتم، کوئری دوباره کند شد و ۲۰۰۰ تا درخواست داد.
336: مفهوم prefetch related. نکاتی که داشت:
بعضی وقت ها هست که ما از یه تیبل دیگه فارین کی زدیم به تیبلی که داریم روش کار میکنیم. تو همین مثال مثلا OrderItem ها به Product
فارین کی زدن و اونجا related_name="order_items" رو گذاشتیم. وقتی داریم با منیجری که مال Product هست کار میکنیم، میتونیم از
متد prefetch_related استفاده کنیم و داخل ورودی بهش کلمه مورد نظر (مثلا استرینگ order_items در این مثال) رو میدیم. بهش میگیم
برو جایی که به این تیبل فارین کی زده و اسم related_name ش رو همچین چیزی گذاشته، اطلاعات اون رو هم بیار. اگه نذاریم، منیجر
Product خودش میاره. ولی ۱۰۰۵ تا کوئری میزنه. اما با این کار میشه ۵ تا کوئری با سرعت بسیار بیشتر. در واقع select_related بهش
می گفتیم برو از تیبلی که بهش فارین کی زدیم، اطلاعات اون رو بیار. prefetch_related برعکس هست و میگه برو از تیبلی که به ما
فارین کی زده، اطلاعات رو بیار. کاربرد هر ۲ تا بسیار بسیار مهمه. آخرین نکته ای که داره، توی html، داخل حلقه ای که برای تمام
محصولات زدیم، میتونیم روی هر محصول روی order_items ش دوباره for بزنیم. اما تو html اون دیگه منیجر نیست. برای این که به منیجری
برای OrderItem ها تبدیل بشه، تو html بعد از نوشتن product.order_items یه .all هم لازم داره. یعنی product.order_items.all باید
بنویسیم تا بشناسه. وگرنه ارور 'RelatedManager' object is not iterable v رو بهمون میده. چون RelatedManager هست و نه Manager.
337: تمرین مهم select related و prefetch related. نکاتی که داشت:
خودم انجام دادم و خیلی تمرین خوبی بود و حدود ۱ ساعت وقتم رو گرفت. اما ارزش داشت. اولی و دومی رو اوکی بودم. سومی هم اوکی بودم.
به غیر از قسمت آخرش که میخواست اسم محصول رو هم بیاره کوئری من درخواست زیاد میداد به دیتابیس. داخل prefetch_related که اسم
items رو نوشته بود، تهش __product گذاشت که یعنی از توی اون product ش هم که فارین کی هست بیار که این دیگه خیلی خفن بود.
338: استفاده از aggregation. نکاتی که داشت:
aggregation یعنی کارهایی که روی تعداد زیادی انجام میدیم. مثل شمردن تعداد کل و ... مثلا تعداد کل یه فیلد از یه ستونی رو
میتونیم بشماریم. دقت کنم که اگه null باشه اون رو نمیشماره. aggregation هایی که داریم، Min, Max, Sum, Avg, Count.
در واقع aggregation ها کارهایی هستن که خودمون میتونیم انجام بدیم با پایتون یا زبان برنامه نویسی دیگه، اما دیتابیس سریعتر
و بهینه تر از ما انجام میده. اگه به تابع aggregate فقط ورودی بدون نام بدیم، خودش اسم پیش فرض برای نتیجه میذاره. اما ما هم
میتونیم بهش اسم بدیم که اسم دلخواه ما بشه مثل کدهایی که نوشتم.
339: استفاده از annotation. نکاتی که داشت:
annotation یعنی نمادگذاری. خلاصه اش اینه که یه متغیر موقت تعریف میکنیم. مثلا full_name که از رو اسم اول و دوم ساخته میشه. اما
داخل تیبل اصلی و دیتابیس تغییر نمیدیم. موقت دیتابیس برای ما میسازه. این مفهوم annotation هست. برای استفاده ازش باید قبلش
expression ها رو یاد بگیریم که این ویدیو و چند تای بعدی همینه. نکات زیادی داره اما دیگه نمینویسم اینجا.
340: نحوه اجرای توابع دیتابیس. نکته داشت. ننوشتم.
341: مفهوم group by. نکته داشت. ننوشتم.
342: Expression Wrapper. نکته داشت. ننوشتم.
343: Custom Manager. نکاتی که داشت:
به صورت پیش فرض توی هر کلاس که از models.Model ارث میبریم، یه متغیر به اسم objects=models.Manager() درست میکنه که ما از
همون منیجر objects همیشه استفاده می کردیم. اگه همون رو بنویسیم که تغییری ایجاد نمیشه ولی مثلا میتونیم اسمش رو به جای
objects بذاریم x مثلا. بعدا اون ور باید بنویسیم مثلا Customer.x.all() که کار بکنه. حالا بریم که کاستوم منیجر درست کنیم.
344: Custom Manager method. نکاتی که داشت:
شروع از اینجاااا

ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۶ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۷ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۸ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۹ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۰ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۱ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ
فصل ۱۲ آپدیت:
ــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــــ

